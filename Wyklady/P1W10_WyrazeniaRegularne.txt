P1W10 - Wyrażenia regularne

Wyrażenia regularne (re, regular expressions) to sposób opisu wzorców tekstu.
Wzorce te możemy wyszukiwać w tekście.
Wyszukane wzorce możemy zamienić, sprawdzać ich poprawność,
wyciągać informacje, np. wypisać wszystkie nazwy plików w tekście,
wszystkie numery telefonów, itp.

Biblioteka obsługująca wyrażenia regularne to re.

Najprostsze wyrażenie regularne to ciąg znaków, np. "kot".

import re

Najważniejsze funkcje.

re.search(wzorzec, tekst)

>>> re.search("kot", "Ala ma kota")
<re.Match object; span=(7, 10), match='kot'>
>>> x.span()
(7, 10)

Uwaga!
x.span() = (x.start(), x.end())

>>> print(re.search("kot", "Ala ma kota"))
<re.Match object; span=(7, 10), match='kot'>
>>> print(re.search("pies", "Ala ma kota"))
None
-------------------------------
re.match - sprawdza dopasowanie na początku tekstu
re.matchfull - sprawdza czy cały tekst pasuje do wzorca

 print(re.match("kot", "Ala ma kota"))
None
>>> print(re.match("Al", "Ala ma kota"))
<re.Match object; span=(0, 2), match='Al'>
-----------------------------------------------------

re.findall - zwraca listę dopasowań

>>> re.findall("a", "Ala ma kota")
['a', 'a', 'a']
>>> re.findall("aa", "Aaaalaaa ma kotaaa")
['aa', 'aa', 'aa']
>>> re.findall("aa", "Aaaaalaaa ma kotaaa")
['aa', 'aa', 'aa', 'aa']

------------------------------
re.sub(wzorzec, nowy, tekst) - zmienia wystąpienia (wszystkie) wzorzec na nowy w tekście
----------------------------
Jeśli chcemy poznać miejsca wystąpień wzorca zamiast tylko wzorców, jak w findall,
musimy użyć finditer.

>>> xl = [m for m in re.finditer("aa", "Aaaaalaaa ma kotaaa")]
>>> xl
[<re.Match object; span=(1, 3), match='aa'>, 
 <re.Match object; span=(3, 5), match='aa'>, 
 <re.Match object; span=(6, 8), match='aa'>, 
 <re.Match object; span=(16, 18), match='aa'>]

>>> for x in xl:
...     print(x.group(), x.span())
...
aa (1, 3)
aa (3, 5)
aa (6, 8)
aa (16, 18)

Możemy też grupować przy pomocy nawiasów podwyrażenia naszego wyrażenia.



>>> w = re.finditer("a(b)(a)", "Aababalabaa ma kotaaba")
>>> wl = list(w)
>>> wl
[<re.Match object; span=(1, 4), match='aba'>, 
 <re.Match object; span=(7, 10), match='aba'>, 
 <re.Match object; span=(19, 22), match='aba'>]

Każdy obiekt na liście wl zawiera informację o dopasowaniu całego wzorca
oraz "podwzorców" wziętych w nawiasy.

>>> for m in wl:
...     print(m.group(0), m.group(1), m.group(2), 
              m.span(0), m.span(1), m.span(2))
...
aba b a (1, 4) (2, 3) (3, 4)
aba b a (7, 10) (8, 9) (9, 10)
aba b a (19, 22) (20, 21) (21, 22)
>>> wl[0].group(3)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: no such group
>>> wl[0].group
<built-in method group of re.Match object at 0x000001ABBE28F600>
>>> wl[0].group()
'aba'
>>> wl[0].group(0)
'aba'

Najprosciej:
matches = [
    (m.group(), m.start(), m.end())
    for m in re.finditer(pattern, text)
]

2. Wyrażenia regularne, które nie są stałymi ciągami znaków

W wyrażeniach regularnych mogą pojawić się symbole,
których oznaczają całe rodziny znaków.

. - dowolny znak (oprócz '\n')
\d - cyfra (0-9)
\w - znak alfanumeryczny (litera lub cyfra)
\s - biały znak (spacja, tab, ...)

\D, \W, \S - znak inny niż ...

Uwaga!
Ponieważ symbole specjalne zaczynają się od "\",
to w wyrażeniu regularnym lepiej używać 'raw string'.

Przykład. 
Wzorzec dwóch cyfr możemy zapisać jako 
'\\d\\d' albo jako r'\d\d'.
Wzorzec dwóch ukośników możemy zapisać jako
'\\\\' albo jako r'\\'.


Możemy oznaczyć ile razy ma wystąpić dany wzorzeć w wyrażeniu:
* - dowolnie wiele razy lub wcale [0, 1, ...]
+ - jeden raz lub więcej, [1,...]
? - raz lub wcale [0,1]
{n} - dokładnie n razy
{n,m} - od n do m razy

Pozycje w tekście:
^ - początek tekstu,
$ - koniec tekstu,
\b - granica słowa

>>> list(re.findall(r'\bm', "Ala ma kotam"))
['m']
>>> list(re.findall(r'\b m', "Ala ma kotam"))
[' m']

Uwaga!
W granicę słowa wchodzą też spacje za słowem
ale mogą one też wejść do dopasowania.

Operacje logiczne - alternatywa |
np. (a|b), 

Zakres operatorów.
Operatory ?, *, +, {m,n} mają najwyższy priorytet.
Wiążą najkrótsze poprawne wyrażenie, które je poprzedza.
Jest to tzw. 
dopasowanie zachłanne - bierzemy tyle, ile to tylko możliwe.

Przykłady.
>>> re.findall('.?', 'abcdefgh')
['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', '']
>>> re.findall('.*', 'abcdefgh')
['abcdefgh', '']
>>> re.findall('.+', 'abcdefgh')
['abcdefgh']
>>> re.findall('.{2,3}', 'abcdefgh')
['abc', 'def', 'gh']

Jeśli chcielibyśmy dopasować minimalny fragment tekstu 
do wzorca, musimy  po operatorze ?, *, +, {m,n} 
postawić znak '?'

>>> re.findall('.??', 'abcdefgh')
['', 'a', '', 'b', '', 'c', '', 'd', '', 'e', '', 'f', '', 'g', '', 'h', '']
>>> re.findall('.*?', 'abcdefgh')
['', 'a', '', 'b', '', 'c', '', 'd', '', 'e', '', 'f', '', 'g', '', 'h', '']
>>> re.findall('.+?', 'abcdefgh')
['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
>>> re.findall('.{2,3}?', 'abcdefgh')
['ab', 'cd', 'ef', 'gh']

Przykład.
Wyszukiwanie w tekście HTML

text = "<tag>pierwszy</tag><tag>drugi</tag>"

print(re.findall(r"<tag>.*</tag>", text))
# ['<tag>pierwszy</tag><tag>drugi</tag>']

print(re.findall(r"<tag>.*?</tag>", text))
# ['<tag>pierwszy</tag>', '<tag>drugi</tag>']

Przykład.

text = "(1)(22)(333)"

print(re.findall(r"\(.*\)", text))
# ['(1)(22)(333)']

print(re.findall(r"\(.*?\)", text))
# ['(1)', '(22)', '(333)']

Uwaga! Znak zapytania po operatorze zmienia
sposób jego interpretacji przez Pythona.
Zmienia więc jego znaczenie, ale nowe znaczenie
jest bliskie znaczeniu bez tego znaku.
W szczególności, jeśli istnieje tylko jeden sposób 
dopasowania wzorca do tekstu, to nie ma znaczenia,
czy wstawimy o operatorach znak zapytania czy nie.

Uwaga! Siła wiązania.
Operatory jednoargumentowe: ?, *, +, {m,n} wiążą najsilniej,
po wyrażeniach zgrupowanych nawiasami (atomach).
W związku z tym ich zakres jest wyznaczany jako pierwszy 
i jest możliwie najmniejszy.
Operator alternatywy, |, wiąże najsłabiej.

Hierarchia wiązania

Atomy: 
znak, np. a
klasa znaków: [abc]
grupa: (ab)
kotwice / lookaroundy: ^, $, (?=...), itd.

Kwantyfikatory: *, +, ?, {m,n}
wiąża poprzedzający atom


Konkatenacja: ab


Alternatywa: a|b


Co dokładnie wiążą kwantyfikatory?

ab* = a (b*) - a, potem b dowolnie wiele razy
(ab)* - ciąg ab powtorzony dowolnie wiele razy (być może zero razy)
(ab)+ - ciąg ab powtórzony jeden lub więcej razy


Wyznacz zasięgi i znaczenie wyrażeń:

ab|cd*  =   ab |   c(d*) = (ab) | (c(d*)) - albo ab albo c i potem ciąg d,
(ab | cd)* 

>>> w = re.finditer('(ab|cd)+', 'mabcd cdalabcala ababcd cdabcd cddd ac')
>>> for i in w: print(i.group())
...
abcd
cd
ab
ababcd
cdabcd
cd
Uwaga! findall zwróci tylko podgrupy naszego wzorca 
ujęte w nawiasach. finditer zwrócił cały wzorzec jako i.group()

>>> re.findall('(ab|cd)+', 'mabcd cdalabcala ababcd cdabcd cddd ac')
['cd', 'cd', 'ab', 'cd', 'cd', 'cd']

(ab)|(cd*)
(ab)|(cd)*


Zakresy znaków
nawiasy kwardratowe, w nawiasach wypisane znaki lub ich zakres:
[abc]
[a-z]
[a-z]|[A-Z]

^ po "[" to negacja
[^0-9] - wszystko co nie jest cyfrą

[abc] to (a|b|c)
\d to [0-9]
\D to [^0-9]
\w to [a-zA-Z0-9]




Grupowanie

Jeśli w wyrażeniu regularnym zgrupujemy jego części przy pomocy
nawiasów, to findall zwróci nam krotki (lub ciągi w przypadku jednej pary nawiasów)
dopasowań do poszczególnych nawiasów.

>>> list(re.findall(r'(\d)\d', r"(3)3(3)3 4567"))
['4', '6']
>>> list(re.findall(r'(\d)(\d)', r"(3)(3)(3)3 4567"))
[('4', '5'), ('6', '7')]

>>> list(re.findall(r'(\d)(\d)', r"(3)3(3)3 4567"))
[('4', '5'), ('6', '7')]
>>> list(re.findall(r'(\d)(\d)', r"(3)(3)(3)3 4567"))
[('4', '5'), ('6', '7')]
>>> list(re.findall(r'\(\d\)\(\d\)', r"(3)(3)(3)3 4567"))
['(3)(3)']
>>> list(re.findall(r'\(\d\)(\d)', r"(3)(3)(3)3 4567"))
['3']
>>> [(m.group(0), m.group(1)) for m in re.finditer(r'\(\d\)(\d)', r"(3)(4)(5)6 4567")]
[('(5)6', '6')]

Opcje dopasowywania - trzeci argument

re.IGNORECASE – ignoruj wielkość liter
re.MULTILINE – ^ i $ działają na liniach
re.DOTALL – . dopasowuje też \n

Prekompilacja

Jeśli wyrażenia regularnego używamy wiele razy warto je
prekompilować
pattern = re.compile(regex)

>>> pattern = re.compile(r"\d\d")
>>> pattern.findall("Ala 23 ma 34 lata i sal35a.")
['23', '34', '35']

3. Przykłady

3.1 Znajdź wszystkie liczby całkowite

"\d*"

3.2 Znajdź wszystkie liczby zmiennopozycjne
"\d+\.\d+

3.3 Znajdź numery telefonu w formacie: trzy grupy po trzy cyfry przedzielone '-'
"\d\d\d-\d\d\d-\d\d\d"
"\d{3}-\d{3}-\d{3}"

>>> list(re.findall(r"\d\d\d-\d\d\d-\d\d\d", "123-234-345-456-567-678-789-890"))
['123-234-345', '456-567-678']
>>> list(re.findall(r"\d{3}-\d{3}-\d{3}", "123-234-345-456-567-678-789-890"))
['123-234-345', '456-567-678']
>>> [m.group(0) for m in re.finditer(r"(\d{3}-){2}\d{3}", "123-234-345-456-567-678-789-890")]
['123-234-345', '456-567-678']

4. Znajdź nazwy plików audio. 
Podziel je na pary uporządkowane, nazwa pliku i rozszerzenie, mp3 lub ogg lub flac.

\b([^.\/\\]+)\.(mp3|ogg|flac)\b - W nazwach plików nie pozwalamy na znaki z listy: ., /, \. 








