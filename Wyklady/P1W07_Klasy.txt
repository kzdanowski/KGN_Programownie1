Klasy/Obiekty w Pythonie

Co to jest klasa? 
Typ danych. Udostępnia 
dane - "informacje, wartości", atrybuty 
oraz 
metody - "funkcje".
W Pythonie wszystko jest klasą: int, float, ...
Użytkownik może definiować swoje klasy.

Korzyści z klas.
1. Hermetyzacja (ang. encapsulation).
2. Polimorfizm.

Definicja klasy.
class NazwaKlasy(SuperKlasa):
    """Komentarz, 
       opis klasy"""
    def __init__(self, parametry) - funkcja tworząca obiekt klasy
    def __str__(self): - funkcja tworząca reprezentację obiektu jako str.
    artybuty klasowe
    metody

Gdy definiujemy klasę często robimy to w pliku o nazwie 
takiej jak nazwa klasy.

Wyróżniamy dwa poziomy:
klasa oraz obiekt danej klasy.
Pewne artybuty i metody są dla całej klasy,
inne (tak jest zazwyczaj) są związane z obiektem danej klasy.


Do pól klasy odwołujemy się przez kropkę:
obiekt.nazwa_pola
Klasa.nazwa_pola,
gdzie obiekt jest obiektem klasy Klasa.


Kopiując obiekty klasy kopiujemy adres do miejsca w pamięci,
czyli referencję do obiektu.

Atrybuty klasy.
__name__  - nazwa klasy
__module__ - moduł klasy
__bases__ - klasy bazowe
__doc__ - dokumentacja
__dict__ - artybuty klasy


Atrybuty obiektu
__dict__ - atrybuty obiektu i ich wartości
__class__ - klasa danego obiektu

Zmienne klasowe 
definiowane wewnątrz klasy,
istnieje jedna taka zmienna dla wszystkich obiektów.

Metody klasy - oznaczone przez @classmethod
Wywoływane przez zmienna.nazwaMetody lub NazwaKlasy.nazwaMetody

Metody statyczne  - oznaczone przez @staticmethod
Wywoływane przez NazwaKlasy.nazwaMetody lub zmienna.nazwaMetody
Nie przyjmują argumentu self ani cls.

2. Dziedziczenie

class Podklasa(Superklasa):
    def __init__(self, param):
       super().__init__(param)
       ......
Obiekty podklasy dziedziczą atrybuty i metody
superklasy.
Można zmieniać metody superklasy.

Każda klasa dziedziczy po object.
Klasa object posiada artybuty:
__class__, __dict__, __doc__, __module__
oraz metody:
__str__(), __init()__, __eq__(),  __hash__().

Przykład w pliku W07_Obiekty.py i omówienie tam.

3.  Przeciążanie operatorów


q1 < q2 -> __lt__(q1, q2)
q1 <= q2  -> __le__(q1, q2)
q1 == q2  -> __eq__(q1, q2)
q1 != q2  -> __ne__(q1, q2)
q1 > q2  -> __gt__(q1, q2)
q1 >= q2  -> __ge__(q1, q2)

q1 + q2  ->  __add__(self, q2)
q1 – q2  -> __sub__(self, q2)
q1 * q2  -> __mul__(self, q2)
q1 ** q2  -> __pow__(self, q2)
q1 / q2  -> __truediv__(self, q2)
q1 // q2 -> __floordiv__(self, q2)




Każda klasa dziedziczy po object.
Klasa object posiada artybuty:
__class__, __dict__, __doc__, __module__
oraz metody:
__str__(), __init()__, __eq__(),  __hash__().



-----------------------------------------
del - zwalnia pamięć z obiektu klasy

-------------------------------------------------

Prywatne atrybuty/metody klasy.
Nazwy takich atrybutów zaczynają się od podkreślenia.
Jest to tylko konwencja, ale bardzo silnie przestrzegana.

class Example:
    def __init__(self):
        self._value = 42  # atrybut "chroniony"

obj = Example()
print(obj._value)  # działa, choć nie zalecane


Nazwy zaczynające się od podwójnego podkreślenia 
Python zmienia na:
__nazwa -> _NazwaKlasy__nazwa

To zachowuje się przy dziedziczeniu.
class A:
    def __init__(self):
        self.__x = 1
        self.y = 2

class B(A):
    def __init__(self):
        super().__init__()
        self.__x = 2  # to inny atrybut niż __x z A!
        self.y = 3
Klasa B ma dwa atrybuty:
_A__x oraz _B__x !



