Programowanie 1, Wykład 04
Funkcje, argumenty, zmienne globalne, zmienne lokalne, struktura programu

1. Funkcje
1.1 Podstawy funkcji

Funkcja to ciąg instrukcji, który wykonuje się jako jeden blok.
Funkcja może przyjmować argumenty, od której zależy jej działanie 
oraz zwracać wartość.

Funkcję w Pythonie definiujemy jako:

def nazwa_funkcji(ciąg_argumentów):
"""Opcjonalny opis funkcji"""
    Cialo_Funkcji

def - słowo kluczowe, informuje o definiowaniu funkcji
ciąg_argumentów - w tym miejscu wprowadzamy zmienne, które będą nam służyć
                  do przekazywania informacji (wartości) do funkcji,
                  może być pusty.
Opcjonalny opis funkcji - tutaj znajduje się opis funkcji, nie musimy go
                          wpisywać.
Cialo_Funkcji - wpisujemy z wcięciem 4 spacji.

Argument formalny/parametr to ciąg zmiennych, które są wymienione w deklaracji funkcji.
Argument aktualny, to argument, z którym funkcja jest wywoływana.

Funkcje otrzymują własne środowisko wykonywania obliczeń,
z własnymi zmiennymi lokalnymi. Mogą też korzystać ze zmiennych globalnych programu.
Funkcje mogą też zwracać wartości przez "return".

Przykład.
def square(n):
    return n*n
Funkcję taką możemy wywołać z różnymi argumentami
a także z argumentem będącym wartością zwróconą przez funkcję,
np. 
square(square(2)) 
zwróci wartość 16.

2 to argument aktualny w square(2)
square(2) to argument aktualny w square(square(2)) 
n to argument formalny w definicji funkcji square

1.2 Argumenty funkcji

Argumenty funkcji mogą otrzymać wartości domyślne.
Jeśli pominiemy je podczas wywołania funkcji, to przyjmą one 
wartości domyślne.
Argumenty takie muszą(!) wystąpić w deklaracji funkcji
po argumentach bez wartości domyślnych.
Przykład
def wiele_argumentow(arg1, arg2 = 2, arg3 = 3):
    print(f'Wartość arg1 = ", arg1)
    print(f'Wartość arg2 = ", arg2)
    print(f'Wartość arg3 = ", arg3)

Co wypisze
wiele_argumentow(5)
wiele_argumentow(5,6)

Argumenty aktualne możemy też podawać do funkcji używając
nazw argumentów formalnych.
Jest to przydatne, gdy lista argumentów jest długa.
Przykład
wiele_argumentow(arg2 = 3, arg1 = 5)

Możemy też użyć nazw tylko części argumentów, ale wtedy argumenty
pozycyjne muszą wystąpić przed argumentami, do których odnieśliśmy 
się przez nazwę.
wiele_argumentow(1, arg3 = 8)

1.3 Nieokreślona ilość argumentów 

Czasem funkcja może przyjąć nieokreśloną ilość argumentów,
jak np. funkcja print. 
print(1, 2, 3, "Ala", [1,2,3], 8)

Definiując taką funkcję używamy argumentu z '*'.

Przykład (za [1], str. 127)
def greeter(*args):
    for name in args:
        print('Welcome', name)

>> greeter('John', 'Denise', 'Phoebe', 'Adam', 'Gryff', 'Jasmine')
Welcome John
Welcome Denise
Welcome Phoebe
Welcome Adam
Welcome Gryff
Welcome Jasmine

Możemy też odwołać się do argumentów nazwanych, za pomocą '**'.

Przykład (za [1], str. 128)
def my_function(*args, **kwargs):
    for arg in args:
        print('arg:', arg)
    for key in kwargs.keys():
        print('key:', key, 'has value: ', kwargs[key])

>> my_function('John', 'Denise', daughter='Phoebe', son='Adam')
>> print('-' * 50)
>> my_function('Paul', 'Fiona', son_number_one='Andrew',
son_number_two='James', daughter='Joselyn')
Wynik:
arg: John
arg: Denise
key: son has value: Adam
key: daughter has value: Phoebe
--------------------------------------------------
arg: Paul
arg: Fiona
key: son_number_one has value: Andrew
key: son_number_two has value: James
key: daughter has value: Joselyn

