Wykład 6. Rekurencja

Rekurencja to sposób rozwiązywania problemu
gdzie podajemy jak rozwiązać przypadki bazowe
a rozwiązania pozostałych przypadków redukujemy do
rozwiązań przypadków bazowych.

Rekurencja to także sposób tworzenia programów/funkcji,
które korzystają z tej techniki.
Programy rekurencyjne są czestso prostsze do zrozumienia
i łatwiejsze do napisania.

Rekurencja to bardzo silnia technika obliczeniowa.

Przykład.
Obliczanie silni.
silnia(n) = n*(n-1)*(n-2)*...*2*1
Możemy obliczyć wartość silni w pęli.
def silnia_loop(n:int)->int:
    silnia = 1
    for i in range(2,n+1):
        silnia *=i
    return silnia

Ale możemy też obliczyć silnię korzystając
z rekurencyjnej zależności:
silnia(0) = 1                  #przypadek bazowy
silnia(n+1) = (n+1)*silnia(n)  #przypadek rekurencyjny
Wtedy, dla n>=1
silnia(n+1) = (n+1)*silnia(n)
            = (n+1)*n*silnia(n-1)
            = (n+1)*n*(n-1)*...*1

W programie rekurencyjnym rozwiązujemy najpierw przypadki bazowe,
potem przypadki wymagające rekurencji.
def silnia_rec(n):
    print(f"Wyołanie silnia_rec({n})")
    if n <= 0:
        print(f"Koniec wywołania silnia({n}), zwracana wartość: {1}")
        return 1
    val =  silnia(n-1)
    print(f"Koniec wywołania silnia({n}), zwracana wartość: {val}")
    return n*val

def silnia_rec_krotko(n):
    if n <= 0: return 1
    return n*silnia(n-1)


Co możemy zrobić źle podczas rekurencji?

1. Możemy nie zaprogramować rozwiązania dla przypadków bazowych
lub możemy umieścić je po przypadkach, które redukujemy.
To może skutkować nie zakończeniem się wywołań rekurencyjnych.

Np. 
def silnia(n):
    val = n*silnia(n-1)
    if n <= 0:
        val =  1
    return val

2. Możemy nie zadbać o to, żeby przypadki zawsze redukowały się
   do przypadków bazowych.
Np.
def silnia(n):
    if n == 0:
        return 1
    val = silnia(n-1)
    return n*val
Jak zachowa się wywołanie silnia(-1)?
Tutaj, przypadkiem bazowym jest tylko wartość n == 0.
Wartości ujemne n nie są bazowe i nie redukują się do bazowych.
Ta funckcja dla wartości ujemnych nie zatrzyma się
choć przypadki bazowe są rozwiązywane na początku.

Dlatego:
1. Zawsze na początku rozwiązujemy przypadki bazowe.
2. Pamiętamy, żeby zadbać o zakończenie wywołań rekurencyjnych.

Jak realizuje się rekurencja?

Gdy wywołujemy jedną funkcję w drugiej, np. funkcje g(3) i g(6)
w f().
def g(n):
    return n+3

def f():
    k = g(3)
    z = g(k)
    return z+2

System operacyjny zatrzymuje wykonywanie funkcji f(5) 
i zaczyna wykonywać funkcję g(3).
Gdy skończy obliczać g(3) wraca do funkcji f(5).
Zawiesza jej działanie aby obliczyć g(6) 
i znowu wraca i kończy obliczać f(5).

Potrzebna do tego pamięć jest rezerwowana na stosie, na specjalnej strukturze w pamięci programu.

Czy rekurencja jest efektywna?
Obecnie rekurencja jest efektywna.
Jednak mamy ograniczoną ilość wywołań rekurencyjnych z powodu rozmiaru pamięci stosu.
Dlatego czasem możemy nie policzyć czegoś rekurencyjnie z tego powodu
a możliwe jest policzenie tego w pętli.

Czy rekurencja jest konieczna?
Zawsze możemy zamienić program wykorzystujący rekurencję na program wykorzystujący dodatkową
pamięć. 
Ale jest to rozwiązanie trudniejsze, mniej czytelne.
Z drugiej strony rekurencja jest często naturalnym sposobem programowania, np. podczas
obsługi takich struktur jak drzewa, grafy, itp.

