Wykład 12. Analiza Danych,
biblioteki pandas, numpy 


import numpy as np
import pandas as pd
from pandas import DataFrame, Series

1. Podstawowe zadania analizy danych

1.1 Wczytywanie danych z różnych źródeł:
pliki csv, json, excel, bazy danych, internet, ...

1.2 Czyszczenie danych 
Pliki, strony internetowe często zawierają
nieuporządkowane dane, zaśmiecone,
niesformatowane, ...

a) usuwanie duplikatów,
b) usuwanie brakujących danych,
c) uzupełnianie danych,
d) naprawa.

1.3 Przekształcanie danych

a) zmiana typów,
b) wyliczanie nowych wartości,
c) dodawanie nowych kolumn.

1.4 Filtrowanie Danych

Wybieranie tylko istotnych dla nas wartości,
np. interesujących nas ludzi,
pomiarów z danego okresu, miejsca, ...

Usuwanie anomalii, danych odstających.

1.5 Grupowanie danych, agregacja wyników

a) Podział danych na klastry
b) obliczanie funkcji prezentujących 
zbiorcze wyniki: suma, średnia, mediana, wariancja, ...
c) obliczanie statystyk w klastrach.

1.6 Łączenie danych

a) z różnych tabel w tej samej bazie danych,
b) z różnych źródeł.

1.7 Wizualizacja

matplotlib, seaborn


2. Pandas, Series

Series jest jednowymiarową kolumną danych.
Można myśleć o niej jako o tablicy lub wektorze.

Różni się od nich tym, że umożliwia szybkie wykonywanie
operacji na elementach tablicy.
Umożliwia tworzenie własnych indeksów.

Tworzenie - patrz plik P1W12_Pandas.python

Podstawowe informacje
Niech s będzie typu Series

Na całym s można wykonywać operacje
bez użycia pętli:
s+10, s*10, s**2.

Ogólniej: s.apply(function)
Można też użyć słownika:
s.map(dict)


Stosować warunki logiczne:

>>> s>15
a    False
b     True
c     True
dtype: bool

Obliczanie statystyk:
s.sum(),
s.mean() - średnia z elementów a, b, c to (a+b+c)/3
s.min(),
s.max(),
s.std(),
s.median().

Filtrować dane, np.
>>> s[s>15]
b    20
c    30
dtype: int64


Można pracować z brakującymi danymi:

>>> s.isna()
a    False
b    False
c    False
dtype: bool
>>> s.notna()
a    True
b    True
c    True
dtype: bool

s.dropna()
s.fillna(value)


Jeśli Series s zawiera ciągi znaków,
możemy użyć s.str:
s.str.upper(),
s.str.lower(),
s.str.contains("a"),
s.str.len(), ...

Uwaga.
Brak wartości w Pythonie symbolizuje 
None.

W pandas jest to pd.NA.
Wartości None są konwertowane do <NA>.

Uwaga.
>>> x=pd.Series([1,None,2, None], dtype='Int64')
>>> x
0       1
1    <NA>
2       2
3    <NA>
dtype: Int64

Ale >>> x=pd.Series([1,None,2, None], dtype='int64')
zgłosi błąd, bo int64 nie obsługuje None.

Brak wartości, pd.NA, wprowadza logikę
trójwartościową:
>>> pd.NA == pd.NA
<NA>

Ale inaczej dla NaT (Not a Time):

>>> pd.NaT == pd.NaT
False
>>> np.nan == np.nan
False

None - brak wartości w Pythonie,
np.nan - brak wartości liczbowej w numpy,
pd.NA - uniwersalny brak wartości,
pd.NaT - Not a Time (pandas).


Przykłady (za ChatGPT).

>>> df = pd.read_csv("P1W12_sprzedaz.csv")
>>> df
   sprzedaz
0     100.0
1     200.0
2       NaN
3     150.0
4     300.0
5     400.0
6       NaN
7     250.0

>>> type(df)
<class 'pandas.core.frame.DataFrame'>

Zmiana na Series.
>>> s = df["sprzedaz"]
>>> s
0    100.0
1    200.0
2      NaN
3    150.0
4    300.0
5    400.0
6      NaN
7    250.0
Name: sprzedaz, dtype: float64
>>> type(s)
<class 'pandas.core.series.Series'>


Brakujące dane.
>>> print(s.isna())
0    False
1    False
2     True
3    False
4    False
5    False
6     True
7    False
Name: sprzedaz, dtype: bool
>>> print("Liczba braków:", s.isna().sum())
Liczba braków: 2

s_clean = s.dropna()

>>> import matplotlib.pyplot as plt
>>> s_clean.plot()
<Axes: >
>>> plt.show()

s_high = s_clean[ s_clean > 200 ]


print("Średnia:", s_high.mean())
print("Suma:", s_high.sum())
print("Minimum:", s_high.min())
print("Maksimum:", s_high.max())
print("Odchylenie std:", s_high.std())

-----------------------------

Obiekty typu Series możemy też traktować jak
wektory.

s1 = pd.Series([1, 2, 3])
s2 = pd.Series([4, 5, 6])

s1+s2,
s1*s2 - iloczyn po współrzędnych
Iloczyn skalarny (dot product):
s1.dot(s2)

Korelacja
s1.corr(s2)

Uwaga!
Series porównują wektory wzgl. indeksów,
nie pozycji.

>>> s1 = pd.Series([1, 2, 3], index=["a", "b", "c"])
>>> s2 = pd.Series([10, 20, 30], index=["b", "c", "d"])
>>> s1+s2
a     NaN
b    12.0
c    23.0
d     NaN
dtype: float64

s1.dot(s2) zgłosi błąd

Jak ujednolicić indeksy?

1. Reset indeksów
s1_reset = s1.reset_index(drop=True)
s2_reset = s2.reset_index(drop=True)

2. Wspólne indeksy
common = s1.index.intersection(s2.index)

s1_common = s1.loc[common]
s2_common = s2.loc[common]

3. Suma indeksów
all_idx = s1.index.union(s2.index)

s1_all = s1.reindex(all_idx)
s2_all = s2.reindex(all_idx)

s1_all_fill = s1_all.fillna(0)
s2_all_fill = s2_all.fillna(0)

Inaczej.

>>> s1a, s2a = s1.align(s2, join="inner")
>>> s1a
b    2
c    3
dtype: int64
>>> s2a
b    10
c    20
dtype: int64

>>> s1o, s2o = s1.align(s2, join="outer")
>>> s1o
a    1.0
b    2.0
c    3.0
d    NaN
dtype: float64
>>> s2o
a     NaN
b    10.0
c    20.0
d    30.0
dtype: float64

2.2 Przykłady zbierania danych

Rentowność 10 letnich obligacji usage
z
Federal Reserve Economic Data (FRED)
>>> import matplotlib as plt 
>>> import pandas_datareader.data as web
>>> gs = web.get_data_fred('GS10')
>>> gs
            GS10
DATE
2021-02-01  1.26
2021-03-01  1.61
2021-04-01  1.64
2021-05-01  1.62
2021-06-01  1.52
2021-07-01  1.32
2021-08-01  1.28
2021-09-01  1.37
2021-10-01  1.58
2021-11-01  1.56
2021-12-01  1.47
2022-01-01  1.76
2022-02-01  1.93
2022-03-01  2.13
2022-04-01  2.75
2022-05-01  2.90
2022-06-01  3.14
2022-07-01  2.90
2022-08-01  2.90
2022-09-01  3.52
2022-10-01  3.98
2022-11-01  3.89
2022-12-01  3.62
2023-01-01  3.53
2023-02-01  3.75
2023-03-01  3.66
2023-04-01  3.46
2023-05-01  3.57
2023-06-01  3.75
2023-07-01  3.90
2023-08-01  4.17
2023-09-01  4.38
2023-10-01  4.80
2023-11-01  4.50
2023-12-01  4.02
2024-01-01  4.06
2024-02-01  4.21
2024-03-01  4.21
2024-04-01  4.54
2024-05-01  4.48
2024-06-01  4.31
2024-07-01  4.25
2024-08-01  3.87
2024-09-01  3.72
2024-10-01  4.10
2024-11-01  4.36
2024-12-01  4.39
2025-01-01  4.63
2025-02-01  4.45
2025-03-01  4.28
2025-04-01  4.28
2025-05-01  4.42
2025-06-01  4.38
2025-07-01  4.39
2025-08-01  4.26
2025-09-01  4.12
2025-10-01  4.06
2025-11-01  4.09
2025-12-01  4.14
>>> gs.plot()
<Axes: xlabel='DATE'>
>>> plt.show()

-------------------------------------
Apple stock prices

>>> import yfinance as yf
>>> aapl = yf.download("AAPL", start="2025-01-01", end="2025-12-31")
[*********************100%***********************]  1 of 1 completed
>>> print(aapl.head())
Price            Close        High         Low        Open    Volume
Ticker            AAPL        AAPL        AAPL        AAPL      AAPL
Date
2025-01-02  242.752106  247.978468  240.731247  247.809220  55740700
2025-01-03  242.264297  243.080598  240.800915  242.264297  40244100
2025-01-06  243.896912  246.216423  242.105013  243.210016  45045600
2025-01-07  241.119476  244.444435  240.263348  241.885999  40856000
2025-01-08  241.607269  242.612732  238.969207  240.830782  37628900

>>> print(aapl.tail())
Price            Close        High         Low        Open    Volume
Ticker            AAPL        AAPL        AAPL        AAPL      AAPL
Date
2025-12-23  272.359985  272.500000  269.559998  270.839996  29642000
2025-12-24  273.809998  275.429993  272.200012  272.339996  17910600
2025-12-26  273.399994  275.369995  272.859985  274.160004  21521800
2025-12-29  273.760010  274.359985  272.350006  272.690002  23715200
2025-12-30  273.079987  274.079987  272.279999  272.809998  22139600

>>> aapl.info()
<class 'pandas.core.frame.DataFrame'>
DatetimeIndex: 249 entries, 2025-01-02 to 2025-12-30
Data columns (total 5 columns):
 #   Column          Non-Null Count  Dtype
---  ------          --------------  -----
 0   (Close, AAPL)   249 non-null    float64
 1   (High, AAPL)    249 non-null    float64
 2   (Low, AAPL)     249 non-null    float64
 3   (Open, AAPL)    249 non-null    float64
 4   (Volume, AAPL)  249 non-null    int64
dtypes: float64(4), int64(1)
memory usage: 11.7 KB



----------------------------------------------

3. DataFrame

Typ danych wielokolumnowy.

'P1W12_data.csv':   
# Name,Age,City
# Alice,30,New York     
# Bob,25,Los Angeles
# Charlie,35,Chicago

df_csv = pd.read_csv('P1W12_data1.csv')
print(df_csv)
      Name  Age           City
0    Alice   30  New York
1      Bob   25    Los Angeles
2  Charlie   35        Chicago


Z kolumn możemy utworzyć serię:
series_from_csv = Series(df_csv['Age'])
print("Series z pliku CSV:")
print(series_from_csv)

>>> df = pd.DataFrame({
...     "imie": ["Ala", "Olek", "Jan"],
...     "wiek": [20, 25, 30],
...     "miasto": ["Warszawa", "Kraków", "Gdańsk"]
... })
>>>
>>> print(df)
   imie  wiek    miasto
0   Ala    20  Warszawa
1  Olek    25    Kraków
2   Jan    30    Gdańsk

>>> df.info()
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 3 entries, 0 to 2
Data columns (total 3 columns):
 #   Column  Non-Null Count  Dtype
---  ------  --------------  -----
 0   imie    3 non-null      object
 1   wiek    3 non-null      int64
 2   miasto  3 non-null      object
dtypes: int64(1), object(2)
memory usage: 204.0+ bytes
>>> df.describe()
       wiek
count   3.0
mean   25.0
std     5.0
min    20.0
25%    22.5
50%    25.0
75%    27.5
max    30.0

>>> df.shape
(3, 3)
>>> df.size
9

>>> df.loc[0]
imie           Ala
wiek            20
miasto    Warszawa
Name: 0, dtype: object

>>> df.loc[1, "wiek"]
np.int64(25)








